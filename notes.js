/*** How we track the data ***/

lobbies = {
  lobbyId1: {
    users: {
      socketId1: 'username1',
      socketId2: 'username2',
      //...
    },
    state: {
      players: {
        socketId1: {
          score: 50,
          doneGuessing: true //Drawers start with doneGuessing = true
        },
        socketId2: {
          score: 50,
          doneGuessing: false
        },
        //...
      },
      rules: {
        maxPlayers: 12,
        numRounds: 8,
        roundTimer: 45, //seconds
      },
      meta: {
        drawPairs: [
          {drawer1: socketId1, drawer2: socketId2,
            compound: {
              word: 'firetruck',
              left 'fire',
              right: 'truck'
            }
          },
          {drawer1: socketId3, drawer2: socketId4,
            compound: {
              word: 'racecar',
              left: 'race',
              right: 'car'
            }
          },
          //...
        ], //length = numRounds
        numPlayers: 5,
      },
      timer: {
        id: null, //id of interval
        timeLeft: 0,
      },
      roundInfo: {
        round: 0,
        compound: {
          word: 'firetruck',
          left: 'fire',
          right: 'truck'
        },
        drawers: ['socketId1', 'socketId2'],
        guessers: ['socketId3', 'socketId4', 'socketId5'],
      }
    }
  },
  lobbyId2: {
    //...
  },
  //...
}



/*** Notes ***/

/*
 * roundInfo is generated and updated based on the current round number
 * plus the info in meta.
 *  - This means that createGameInstance should probably not initialize the round;
 *    instead, we can use a separate initializeRound function.
 * 
 * Will socketId be needed on the frontend in case of duplicate usernames?
 *  - If we tried to update one thing at a time - i.e., "update Player 1's
 *    score to 76" - we would need to pass the id. 
 *  - If we send a whole dict at a time that's better, but then the dict can't
 *    have duplicate keys. So we end up with a similar problem.
 *  - So we probably should pass the socketId's to the frontend. 
 * 
 * Players and users are each keyed by socketId's, but keep track of different things
 *  - Users needs to exist before the state has been generated
 *  - We could add to it after the round has started and keep track of everything
 *    in users, but it makes sense to keep game data in the state object I think.
 * 
 * Since we have the guesser and drawer arrays, we shouldn't need to keep
 * track of that in players.
 */



/*** What we send to the frontend ***/

// Timer updates: integer time left

// Beginning of round:
// - Each drawer is told they are a drawer, and the word they have to draw
// - Each guesser is told they are a guesser

// [Guessing and returning correctness stuff]
// [Posting messages/wrong guesses to the chat stuff]

// Whenever score is updated during the round
scores = {
  socketId1: {
    username: 'username1',
    score: 55,
    drawer: 0, //0 = not drawer, 1 = left drawer, 2 = right drawer
    doneGuessing: true,
  },
  socketId2: {
    username: 'username2',
    score: 37,
    drawer: 0, //0 = not drawer, 1 = left drawer, 2 = right drawer
    doneGuessing: false
  },
  //...
}
// This will be generated by a function, creating this from the appropriate
// parts of gameInstance
// Note that which drawer is which matters since the order of the word matters